buddy system设计文档

基本原理：

		伙伴系统是一种内存分配算法，通常用于管理固定大小的内存块，这些内存块的大小是2的幂次方。在分配内存时，系统会对比当前块大小和需求，如果当前需求小于块大小的1/2，那么将块二分，再递归地进行下去。
	
		因此，我们可以很自然的想到完美贴合这一特效地数据结构--二叉树。而且这是一棵非常漂亮的满二叉树。在这棵树中，只有最底层的叶子结点是事实存在的内存块，为了有效利用代码的page结构体和避免树深度过大，我们可以以一个页为叶子的单位。(也可以以自定义的大小)。而除了叶子结点以外的所有结点，都是抽象的存在，意义是当前结点合并了多少个叶子。当我们分配内存的时候，只需要根据当前的结点找到它能联系的最左叶节点，从这个叶子结点开始到其最右叶结点这一个区间的所有页都归他了。

实现基本的二叉树结构

		首先不管页实现一个分配一个单位内存的基本的数据结构。
		可以使用传统的结点套节点的二叉树，但是突然受到小根堆的启发，完全二叉树就已经可以简单的用数组来表示了，更别提满二叉树了。于是使用数组（由于我们正在实现分配内存的大东西，所以似乎lib库没有给到malloc一类的函数，不然有点套娃了。这里选择开一个很大的数组，或者是也可以用链表来实现数组的功能，只是在随机访问方面，如果用链表的话开销会比直接老老实实建一棵树然后访问还大），树根下标为0，于是
		·左孩子的下标为：index * 2 + 1
		·右孩子的下标为：index * 2 + 1
		·父亲的下标为：(index - 1) / 2
		因为是满二叉树所以不用像小根堆一样担心访问到不该访问的地方。
		使用node_capacity数组来记录对应位置结点的剩余内存容量。比如，node_capacity[0] = 114514就代表了我们的0号结点，也就是根节点（也就是整个伙伴系统）还剩下114514个单位内存。
		初始化内存时，依据满二叉树的性质对node_capacity的内容进行修改：如0号结点有16个单位内存，那么node_capacity[1]、node_capacity[2]作为其孩子就只有8，node_capacity[3]就只剩4……以此类推。 以下为图示
											| 4 | 
										 | 2 | | 2 |
										|1| |1||1| |1|
							放到node_capacity里是这样：
								4   2   2   1   1   1   1   
								[0] [1] [2] [3] [4] [5] [6]
		在分配内存时，原理是从根开始，如果当前结点的某个孩子的容量大于等于需求，那么转为以那个孩子进行分配，否则当前结点进行分配，同时把当前结点的剩余容量置为0。由于我们的非叶子结点是抽象的，我们的返回值事实上是分配结点的最左叶子结点在所有叶子结点组成的数组或者链表的下标。这可能有点绕，让我们看到上方的图：
		我们的所有叶子节点，也就是最底层的结点组成了一个数组或链表。如果我现在被分配到了二叉树的2号结点，也就是第二层右边的|2|，那么我事实上返回的是|2|的左孩子（因为只有一层，所以直接返回左孩子），也就是第三层的第三个|1|在叶子节点数组的下标2。
		在拿到offset之后，在offset之后的申请的大小个单位内存就归申请者所有了。
		之后进行回溯，更新所有父亲结点的剩余容量为其孩子节点中的最大值。
		我们有以下几个规则遵照：
		所有父亲结点的值是两个孩子中较大的那个。这样做可以避免一些欺骗性的结果，假如我们把父亲结点的容量设为孩子的之和，那么可能出现父亲看似可以满足需求量，但实际上必须得每个孩子都出一点内存才能满足，这是我们不愿意看到的。我们需要的是单独的一边。
		如果需求量大于根节点的剩余容量，那么无法完成分配。
		分配内存时，如果两个子节点都能满足需求，我们选择剩余容量小的孩子进行分配。这样做可以减少内存碎片。
		
		在回收内存时，我们传入的是刚刚分配结点产生的叶子数组的索引offset。因为我们可以很轻易的根据给定的叶子结点向上回溯到第一个容量为0的结点，也就是刚刚分配时找到的结点。然后继续回溯把其父亲结点的剩余内存加回来。


把叶子单元换成页

	这里就很明显了，因为分配时返回的是offset而不是某个特定单位、结构的内存，所以我们只需要根据单位的大小构造对应的数组或者链表，在分配时根据offset一直定位到数组、链表的对应位置然后分配出去即可。